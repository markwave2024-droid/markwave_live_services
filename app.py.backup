import os
from dotenv import load_dotenv
from fastapi import FastAPI
from fastapi.responses import RedirectResponse
from fastapi.middleware.cors import CORSMiddleware

from models import HealthResponse
from routers import users, products, purchases

# Load environment variables from .env
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
ENV_PATH = os.path.join(BASE_DIR, ".env")
load_dotenv(ENV_PATH)

# Validate Neo4j environment variables
if not os.getenv("NEO4J_URI"):
    raise RuntimeError("NEO4J_URI is missing. Ensure .env is correctly configured.")
if not os.getenv("NEO4J_PASSWORD"):
    raise RuntimeError("NEO4J_PASSWORD is missing. Ensure .env is correctly configured.")

# Initialize FastAPI app
app = FastAPI(
    title="Markwave Live Services API",
    version="1.0.0",
    description=(
        "Buffalokart / Markwave live services API. "
        "Provides user onboarding, verification, product and purchase endpoints "
        "backed by Neo4j."
    ),
    docs_url="/docs",
    redoc_url="/redoc",
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(users.router)
app.include_router(products.router)
app.include_router(purchases.router)

# Pydantic models for request validation
class UserCreate(BaseModel):
    mobile: str = Field(..., description="User's mobile number", example="9876543210")
    first_name: str = Field(..., description="User's first name", example="John")
    last_name: str = Field(..., description="User's last name", example="Doe")
    refered_by_mobile: str = Field(..., description="Referrer's mobile number", example="9876543211")
    refered_by_name: str = Field(..., description="Referrer's name", example="Jane Doe")

    class Config:
        schema_extra = {
            "example": {
                "mobile": "9876543210",
                "first_name": "John",
                "last_name": "Doe",
                "refered_by_mobile": "9876543211",
                "refered_by_name": "Jane Doe"
            }
        }

class UserUpdate(BaseModel):
    name: Optional[str] = Field(None, description="Full name", example="John Doe")
    email: Optional[str] = Field(None, description="Email address", example="john@example.com")
    first_name: Optional[str] = Field(None, description="First name", example="John")
    last_name: Optional[str] = Field(None, description="Last name", example="Doe")
    gender: Optional[str] = Field(None, description="Gender", example="Male")
    occupation: Optional[str] = Field(None, description="Occupation", example="Engineer")
    dob: Optional[str] = Field(None, description="Date of birth (MM-DD-YYYY)", example="01-15-1990")
    address: Optional[str] = Field(None, description="Address", example="123 Main St")
    city: Optional[str] = Field(None, description="City", example="Mumbai")
    state: Optional[str] = Field(None, description="State", example="Maharashtra")
    aadhar_number: Optional[str] = Field(None, description="Aadhar number", example="1234-5678-9012")
    pincode: Optional[str] = Field(None, description="PIN code", example="400001")
    aadhar_front_image_url: Optional[str] = Field(None, description="Aadhar front image URL")
    aadhar_back_image_url: Optional[str] = Field(None, description="Aadhar back image URL")
    verified: Optional[bool] = Field(None, description="Verification status")
    custom_fields: Optional[Dict[str, Any]] = Field(None, description="Custom fields")

class UserVerify(BaseModel):
    mobile: str = Field(..., description="User's mobile number", example="9876543210")
    device_id: str = Field(..., description="Device ID", example="device123")
    device_model: str = Field(..., description="Device model", example="iPhone 12")

class Purchase(BaseModel):
    User_mobile: str = Field(..., description="User's mobile number", example="9876543210")
    item: str = Field(..., description="Item purchased", example="Buffalo Milk")
    details: str = Field(..., description="Purchase details", example="1 liter organic buffalo milk")

# Response models
class HealthResponse(BaseModel):
    status: str = Field(..., example="ok")

class UserResponse(BaseModel):
    id: str = Field(..., description="User UUID")
    mobile: str = Field(..., description="Mobile number")
    first_name: str = Field(..., description="First name")
    last_name: str = Field(..., description="Last name")
    refered_by_mobile: str = Field(..., description="Referrer mobile")
    refered_by_name: str = Field(..., description="Referrer name")

class StandardResponse(BaseModel):
    statuscode: int = Field(..., description="Status code")
    status: str = Field(..., description="Status message")
    message: str = Field(..., description="Response message")

class UserCreateResponse(StandardResponse):
    user: UserResponse = Field(..., description="User data")

class UserListResponse(StandardResponse):
    users: List[Dict[str, Any]] = Field(..., description="List of users")

class UserDetailResponse(StandardResponse):
    user: Dict[str, Any] = Field(..., description="User details")

class ProductResponse(BaseModel):
    statuscode: int = Field(..., description="Status code")
    status: str = Field(..., description="Status message")
    product: Dict[str, Any] = Field(..., description="Product data")

class ProductListResponse(BaseModel):
    statuscode: int = Field(..., description="Status code")
    status: str = Field(..., description="Status message")
    products: List[Dict[str, Any]] = Field(..., description="List of products")

class VerifyResponse(BaseModel):
    statuscode: int = Field(..., description="Status code")
    status: str = Field(..., description="Status message")
    message: str = Field(..., description="Response message")
    user: Dict[str, Any] = Field(..., description="User data")
    otp: Optional[str] = Field(None, description="Generated OTP if applicable")

class PurchaseResponse(StandardResponse):
    pass

def build_update_clauses(user_update: dict) -> tuple[list, dict]:
    set_clauses = []
    params = {}

    # Standard fields
    if user_update.get('name') is not None:
        set_clauses.append("u.name = $name")
        params["name"] = user_update['name']
    if user_update.get('email') is not None:
        set_clauses.append("u.email = $email")
        params["email"] = user_update['email']
        set_clauses.append("u.verified = true")
        set_clauses.append("u.isFormFilled = true")
    if user_update.get('first_name') is not None:
        set_clauses.append("u.first_name = $first_name")
        params["first_name"] = user_update['first_name']
    if user_update.get('last_name') is not None:
        set_clauses.append("u.last_name = $last_name")
        params["last_name"] = user_update['last_name']
    if user_update.get('gender') is not None:
        set_clauses.append("u.gender = $gender")
        params["gender"] = user_update['gender']
    if user_update.get('occupation') is not None:
        set_clauses.append("u.occupation = $occupation")
        params["occupation"] = user_update['occupation']
    if user_update.get('dob') is not None:
        try:
            dob_date = datetime.datetime.strptime(user_update['dob'], '%m-%d-%Y').date()
            set_clauses.append("u.dob = $dob")
            params["dob"] = dob_date
        except ValueError:
            # Invalid date format, skip or handle
            pass
    if user_update.get('address') is not None:
        set_clauses.append("u.address = $address")
        params["address"] = user_update['address']
    if user_update.get('city') is not None:
        set_clauses.append("u.city = $city")
        params["city"] = user_update['city']
    if user_update.get('state') is not None:
        set_clauses.append("u.state = $state")
        params["state"] = user_update['state']
    if user_update.get('aadhar_number') is not None:
        set_clauses.append("u.aadhar_number = $aadhar_number")
        params["aadhar_number"] = user_update['aadhar_number']
    if user_update.get('pincode') is not None:
        set_clauses.append("u.pincode = $pincode")
        params["pincode"] = user_update['pincode']
    if user_update.get('aadhar_front_image_url') is not None:
        set_clauses.append("u.aadhar_front_image_url = $aadhar_front_image_url")
        params["aadhar_front_image_url"] = user_update['aadhar_front_image_url']
    if user_update.get('aadhar_back_image_url') is not None:
        set_clauses.append("u.aadhar_back_image_url = $aadhar_back_image_url")
        params["aadhar_back_image_url"] = user_update['aadhar_back_image_url']
    if user_update.get('verified') is not None:
        set_clauses.append("u.verified = $verified")
        params["verified"] = user_update['verified']
    
    # Custom fields
    if user_update.get('custom_fields'):
        for key, value in user_update['custom_fields'].items():
            safe_key = key.replace(" ", "_").replace("-", "_")
            set_clauses.append(f"u.{safe_key} = ${safe_key}")
            params[safe_key] = value

    return set_clauses, params

@app.get("/", include_in_schema=False)
async def read_root():
    """Redirect to the interactive API documentation."""
    return RedirectResponse(url="/docs")

@app.get(
    "/health",
    tags=["System"],
    summary="Health check",
    description="Simple liveness probe that returns an OK status if the service is up.",
    response_model=HealthResponse,
    responses={
        200: {
            "description": "Service is healthy",
            "content": {
                "application/json": {
                    "example": {"status": "ok"}
                }
            }
        }
    }
)
async def health_check():
    return {"status": "ok"}

@app.post(
    "/users",
    tags=["Users"],
    summary="Create or fetch user by mobile",
    description=(
        "Create a new user if the given mobile does not exist, or return the existing "
        "user if it already exists. A stable Neo4j UUID is assigned on first creation."
    ),
    response_model=UserCreateResponse,
    responses={
        200: {
            "description": "User already exists",
            "content": {
                "application/json": {
                    "example": {
                        "statuscode": 200,
                        "status": "success",
                        "message": "User already exists",
                        "user": {
                            "id": "uuid-123",
                            "mobile": "9876543210",
                            "first_name": "John",
                            "last_name": "Doe",
                            "refered_by_mobile": "9876543211",
                            "refered_by_name": "Jane Doe"
                        }
                    }
                }
            }
        },
        201: {
            "description": "User created successfully",
            "content": {
                "application/json": {
                    "example": {
                        "statuscode": 201,
                        "status": "success",
                        "message": "User created or updated",
                        "user": {
                            "id": "uuid-456",
                            "mobile": "9876543210",
                            "first_name": "John",
                            "last_name": "Doe",
                            "refered_by_mobile": "9876543211",
                            "refered_by_name": "Jane Doe"
                        }
                    }
                }
            }
        },
        500: {"description": "Internal server error"}
    }
)
@app.post(
    "/users/",
    tags=["Users"],
    include_in_schema=False,
)
async def create_user(user_data: UserCreate):
    try:
        driver = get_driver()
        try:
            with driver.session() as session:
                # Check if user already exists
                existing = session.run(
                    "MATCH (u:User {mobile: $mobile}) RETURN u",
                    mobile=user_data.mobile
                ).single()

                if existing:
                    existing_props = dict(existing["u"])
                    return {
                        "statuscode": 200,
                        "status": "success",
                        "message": "User already exists",
                        "user": existing_props
                    }

                # Create or update user, assigning a stable unique id on first creation
                result = session.run(
                    "MERGE (u:User {mobile: $mobile}) "
                    "ON CREATE SET u.id = randomUUID() "
                    "SET u.first_name = $first_name,u.last_name = $last_name,u.mobile = $mobile,u.refered_by_mobile = $refered_by_mobile,u.refered_by_name = $refered_by_name "
                    "RETURN u.id AS id, u.mobile AS mobile, u.first_name AS first_name, u.last_name AS last_name,u.refered_by_mobile AS refered_by_mobile,u.refered_by_name AS refered_by_name",
                    **user_data.dict()
                )
                record = result.single()
                return {
                    "statuscode": 201,
                    "status": "success",
                    "message": "User created or updated",
                    "user": {
                        "id": record["id"],
                        "mobile": record["mobile"],
                        "first_name": record["first_name"],
                        "last_name": record["last_name"],
                        "refered_by_mobile": record["refered_by_mobile"],
                        "refered_by_name": record["refered_by_name"],
                    },
                }
        finally:
            driver.close()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.put(
    "/users/{mobile}",
    tags=["Users"],
    summary="Update user by mobile",
    description="Update profile and KYC details for a user identified by mobile number.",
    response_model=Dict[str, Any],
    responses={
        200: {
            "description": "User updated successfully",
            "content": {
                "application/json": {
                    "example": {
                        "statuscode": 200,
                        "status": "success",
                        "message": "User updated successfully",
                        "updated_fields": 3,
                        "user": {
                            "id": "uuid-123",
                            "mobile": "9876543210",
                            "first_name": "John",
                            "last_name": "Doe",
                            "email": "john@example.com"
                        }
                    }
                }
            }
        },
        404: {"description": "User not found"},
        500: {"description": "Internal server error"}
    }
)
async def update_user(mobile: str, user_update: UserUpdate):
    try:
        driver = get_driver()
        try:
            with driver.session() as session:
                # Check if user exists
                result = session.run("MATCH (u:User {mobile: $mobile}) RETURN u", mobile=mobile)
                user = result.single()
                
                if not user:
                    raise HTTPException(status_code=404, detail="User not found")
                
                set_clauses, params = build_update_clauses(user_update.dict(exclude_unset=True))
                params["mobile"] = mobile
                
                if set_clauses:
                    query = f"MATCH (u:User {{mobile: $mobile}}) SET {', '.join(set_clauses)} RETURN u"
                    result = session.run(query, **params)
                    updated = result.single()["u"] if result.single() else None
                    updated_data = dict(updated) if updated is not None else None
                else:
                    updated_data = None
               
                return {"statuscode": 200, "status": "success", "message": "User updated successfully", "updated_fields": len(set_clauses), "user": updated_data}
        finally:
            driver.close()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.put(
    "/users/id/{user_id}",
    tags=["Users"],
    summary="Update user by UUID",
    description="Update profile and KYC details for a user identified by Neo4j UUID id.",
    response_model=Dict[str, Any],
    responses={
        200: {
            "description": "User updated successfully",
            "content": {
                "application/json": {
                    "example": {
                        "statuscode": 200,
                        "status": "success",
                        "message": "User updated successfully",
                        "updated_fields": 2,
                        "user": {
                            "id": "uuid-123",
                            "mobile": "9876543210",
                            "dob": "15-01-1990"
                        }
                    }
                }
            }
        },
        404: {"description": "User not found"},
        500: {"description": "Internal server error"}
    }
)
async def update_user_by_id(user_id: str, user_update: UserUpdate):
    try:
        driver = get_driver()
        try:
            with driver.session() as session:
                result = session.run("MATCH (u:User {id: $id}) RETURN u", id=user_id)
                user = result.single()

                if not user:
                    raise HTTPException(status_code=404, detail="User not found")

                set_clauses, params = build_update_clauses(user_update.dict(exclude_unset=True))
                params["id"] = user_id

                if set_clauses:
                    query = f"MATCH (u:User {{id: $id}}) SET {', '.join(set_clauses)} RETURN u"
                    result = session.run(query, **params)
                    record = result.single()
                    updated = record["u"] if record else None
                    updated_data = dict(updated) if updated is not None else None
                    # Convert dob to dd-mm-yyyy string if present
                    if updated_data and 'dob' in updated_data:
                       dob = updated_data['dob']
                       if isinstance(dob, datetime.date):
                            updated_data['dob'] = dob.strftime('%d-%m-%Y')
                       elif isinstance(dob, Date):
                            updated_data['dob'] = f"{dob.day:02d}-{dob.month:02d}-{dob.year}"
                else:
                    updated_data = None

                return {"statuscode": 200, "status": "success", "message": "User updated successfully", "updated_fields": len(set_clauses), "user": updated_data}
        finally:
            driver.close()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get(
    "/users/referrals",
    tags=["Users"],
    summary="List unverified referred users",
    description="Return users who were referred but are not yet verified customers.",
    response_model=UserListResponse,
    responses={
        200: {
            "description": "List of unverified referred users",
            "content": {
                "application/json": {
                    "example": {
                        "statuscode": 200,
                        "status": "success",
                        "users": [
                            {
                                "id": "uuid-123",
                                "mobile": "9876543210",
                                "first_name": "John",
                                "last_name": "Doe",
                                "refered_by_name": "Jane Doe",
                                "refered_by_mobile": "9876543211"
                            }
                        ]
                    }
                }
            }
        },
        500: {"description": "Internal server error"}
    }
)
async def get_new_referrals():
    try:
        driver = get_driver()
        try:
            with driver.session() as session:
                result = session.run("MATCH (u:User) WHERE u.verified = false OR u.verified is null RETURN u.id, u.mobile, u.first_name, u.last_name,u.refered_by_name,u.refered_by_mobile")
                users = [
                    {
                        "id": record["u.id"],
                        "mobile": record["u.mobile"],
                        "first_name": record["u.first_name"],
                        "last_name": record["u.last_name"],
                        "refered_by_name": record["u.refered_by_name"],
                        "refered_by_mobile": record["u.refered_by_mobile"]
                    }
                    for record in result
                ]
            return {"statuscode": 200, "status": "success", "users": users}
        finally:
            driver.close()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get(
    "/users/customers",
    tags=["Users"],
    summary="List verified customers",
    description="Return all users marked as verified customers in Neo4j.",
    response_model=UserListResponse,
    responses={
        200: {
            "description": "List of verified customers",
            "content": {
                "application/json": {
                    "example": {
                        "statuscode": 200,
                        "status": "success",
                        "users": [
                            {
                                "id": "uuid-123",
                                "mobile": "9876543210",
                                "first_name": "John",
                                "last_name": "Doe",
                                "isFormFilled": True,
                                "refered_by_name": "Jane Doe",
                                "refered_by_mobile": "9876543211",
                                "verified": True
                            }
                        ]
                    }
                }
            }
        },
        500: {"description": "Internal server error"}
    }
)
async def get_existing_customers():
    try:
        driver = get_driver()
        try:
            with driver.session() as session:
                result = session.run("MATCH (u:User {verified:true}) RETURN u.id, u.mobile, u.first_name, u.last_name, u.isFormFilled, u.refered_by_name, u.refered_by_mobile, u.verified")
                users = [
                    {
                        "id": record["u.id"],
                        "mobile": record["u.mobile"],
                        "first_name": record["u.first_name"],
                        "last_name": record["u.last_name"],
                        "isFormFilled": record["u.isFormFilled"],
                        "refered_by_name": record["u.refered_by_name"],
                        "refered_by_mobile": record["u.refered_by_mobile"],
                        "verified": record["u.verified"]
                    }
                    for record in result
                ]
            return {"statuscode": 200, "status": "success", "users": users}
        finally:
            driver.close()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get(
    "/users/{mobile}",
    tags=["Users"],
    summary="Get user details by mobile",
    description="Fetch full user node properties using the mobile number.",
    response_model=UserDetailResponse,
    responses={
        200: {
            "description": "User details retrieved successfully",
            "content": {
                "application/json": {
                    "example": {
                        "statuscode": 200,
                        "status": "success",
                        "user": {
                            "id": "uuid-123",
                            "mobile": "9876543210",
                            "first_name": "John",
                            "last_name": "Doe",
                            "email": "john@example.com",
                            "verified": True
                        }
                    }
                }
            }
        },
        404: {"description": "User not found"},
        500: {"description": "Internal server error"}
    }
)
async def get_user_details(mobile: str):
    try:
        driver = get_driver()
        try:
            with driver.session() as session:
                result = session.run("MATCH (u:User {mobile: $mobile}) RETURN u", mobile=mobile)
                user_record = result.single()
                
                if not user_record:
                    raise HTTPException(status_code=404, detail="User not found")
                
                user_node = user_record["u"]
                user_data = dict(user_node)
                
                return {"statuscode": 200, "status": "success", "user": user_data}
        finally:
            driver.close()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get(
    "/users/id/{user_id}",
    tags=["Users"],
    summary="Get user details by UUID",
    description="Fetch full user node properties using the generated UUID id. Date of birth is formatted as DD-MM-YYYY.",
    response_model=UserDetailResponse,
    responses={
        200: {
            "description": "User details retrieved successfully",
            "content": {
                "application/json": {
                    "example": {
                        "statuscode": 200,
                        "status": "success",
                        "user": {
                            "id": "uuid-123",
                            "mobile": "9876543210",
                            "first_name": "John",
                            "last_name": "Doe",
                            "dob": "15-01-1990",
                            "verified": True
                        }
                    }
                }
            }
        },
        404: {"description": "User not found"},
        500: {"description": "Internal server error"}
    }
)
async def get_user_details_by_id(user_id: str):
    """Fetch full user details using generated unique id instead of mobile."""
    try:
        driver = get_driver()
        try:
            with driver.session() as session:
                result = session.run("MATCH (u:User {id: $id}) RETURN u", id=user_id)
                user_record = result.single()

                if not user_record:
                    raise HTTPException(status_code=404, detail="User not found")

                user_node = user_record["u"]
                user_data = dict(user_node)
                # Convert dob to dd-mm-yyyy string if present
                if 'dob' in user_data:
                    dob = user_data['dob']
                    if isinstance(dob, datetime.date):
                        user_data['dob'] = dob.strftime('%d-%m-%Y')
                    elif isinstance(dob, Date):
                        user_data['dob'] = f"{dob.day:02d}-{dob.month:02d}-{dob.year}"

                return {"statuscode": 200, "status": "success", "user": user_data}
        finally:
            driver.close()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get(
    "/products/{product_id}",
    tags=["Products"],
    summary="Get product details",
    description="Fetch a single BUFFALO product node by its id from the Neo4j database.",
    response_model=ProductResponse,
    responses={
        200: {
            "description": "Product details retrieved successfully",
            "content": {
                "application/json": {
                    "example": {
                        "statuscode": 200,
                        "status": "success",
                        "product": {
                            "id": "buffalo-001",
                            "name": "Premium Buffalo Milk",
                            "price": 80,
                            "description": "Fresh organic buffalo milk",
                            "available": True
                        }
                    }
                }
            }
        },
        404: {"description": "Product not found"},
        500: {"description": "Internal server error"}
    }
)
async def get_product_details(product_id: str):
    """Return product details for a given product id from Neo4j database."""
    try:
        driver = get_driver()
        try:
            with driver.session() as session:
                result = session.run("MATCH (n:BUFFALO) WHERE n.id=$product_id RETURN n", product_id=product_id)
                record = result.single()
                
                if not record:
                    raise HTTPException(status_code=404, detail="Product not found")
                
                product_node = record["n"]
                product_data = dict(product_node)
                
                return {"statuscode": 200, "status": "success", "product": product_data}
        finally:
            driver.close()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get(
    "/products",
    tags=["Products"],
    summary="List all buffalo products",
    description="Return all PRODUCT:BUFFALO nodes stored in Neo4j database.",
    response_model=ProductListResponse,
    responses={
        200: {
            "description": "List of all buffalo products",
            "content": {
                "application/json": {
                    "example": {
                        "statuscode": 200,
                        "status": "success",
                        "products": [
                            {
                                "id": "buffalo-001",
                                "name": "Premium Buffalo Milk",
                                "price": 80,
                                "available": True
                            },
                            {
                                "id": "buffalo-002",
                                "name": "Buffalo Ghee",
                                "price": 500,
                                "available": True
                            }
                        ]
                    }
                }
            }
        },
        500: {"description": "Internal server error"}
    }
)
async def get_products():
    """Return all buffalo products stored in Neo4j as PRODUCT:BUFFALO nodes."""
    try:
        driver = get_driver()
        try:
            with driver.session() as session:
                result = session.run("MATCH (p:PRODUCT:BUFFALO) RETURN p")
                products = [dict(record["p"]) for record in result]
            return {"statuscode": 200, "status": "success", "products": products}
        finally:
            driver.close()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post(
    "/users/verify",
    tags=["Users"],
    summary="Verify referred user and issue OTP",
    description=(
        "Verify whether a referred user exists. If already verified, returns user "
        "details. If not verified, generates and returns an OTP with user details."
    ),
    response_model=VerifyResponse,
    responses={
        200: {
            "description": "User verification status",
            "content": {
                "application/json": {
                    "examples": {
                        "already_verified": {
                            "summary": "User already verified",
                            "value": {
                                "statuscode": 200,
                                "status": "success",
                                "message": "User already verified",
                                "user": {
                                    "id": "uuid-123",
                                    "mobile": "9876543210",
                                    "verified": True
                                }
                            }
                        },
                        "new_verification": {
                            "summary": "New user verified with OTP",
                            "value": {
                                "statuscode": 200,
                                "status": "success",
                                "message": "New user verified",
                                "otp": "123456",
                                "user": {
                                    "id": "uuid-123",
                                    "mobile": "9876543210",
                                    "verified": False
                                }
                            }
                        }
                    }
                }
            }
        },
        300: {"description": "User not found or not a new referral"},
        500: {"description": "Internal server error"}
    }
)
async def verify_user(user_data: UserVerify):
    try:
        driver = get_driver()
        try:
            with driver.session() as session:
                # Check if user exists and is new_referral and not verified
                result = session.run(
                    "MATCH (u:User {mobile: $mobile}) RETURN u.referral_type AS type, u.verified AS verified, properties(u) AS user_props",
                    mobile=user_data.mobile
                )
                record = result.single()
                if not record:
                    raise HTTPException(status_code=300, detail="User not found")
                if record["verified"]:
                    user_props = dict(record["user_props"])
                    # Convert dob to dd-mm-yyyy string if present
                    if 'dob' in user_props:
                        dob = user_props['dob']
                        if isinstance(dob, datetime.date):
                            user_props['dob'] = dob.strftime('%d-%m-%Y')
                        elif isinstance(dob, Date):
                            user_props['dob'] = f"{dob.day:02d}-{dob.month:02d}-{dob.year}"
                    return {"statuscode": 200, "status": "success", "message": "User already verified", "user": user_props}
                elif record:
                    # Generate OTP
                    otp = str(random.randint(100000, 999999))
                    user_props = dict(record["user_props"])
                    user_props['verified'] = False
                    user_props['otp'] = otp
                    # Convert dob to dd-mm-yyyy string if present
                    if 'dob' in user_props:
                        dob = user_props['dob']
                        if isinstance(dob, datetime.date):
                            user_props['dob'] = dob.strftime('%d-%m-%Y')
                        elif isinstance(dob, Date):
                            user_props['dob'] = f"{dob.day:02d}-{dob.month:02d}-{dob.year}"
                    return {"statuscode": 200, "status": "success", "message": "New user verified", "otp": otp, "user": user_props}
                else:
                    raise HTTPException(status_code=300, detail="User not a new referral")
        finally:
            driver.close()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post(
    "/purchases/",
    tags=["Purchases"],
    summary="Record a purchase for a user",
    description=(
        "Create a PURCHASE relationship from a user (by mobile) to a new Purchase "
        "node with item and details. The purchase gets a unique UUID."
    ),
    response_model=PurchaseResponse,
    responses={
        200: {
            "description": "Purchase recorded successfully",
            "content": {
                "application/json": {
                    "example": {
                        "statuscode": 200,
                        "status": "success",
                        "message": "Purchase recorded"
                    }
                }
            }
        },
        500: {"description": "Internal server error"}
    }
)
async def create_purchase(purchase_data: Purchase):
    try:
        driver = get_driver()
        try:
            with driver.session() as session:
                session.run(
                    "MATCH (u:User {mobile: $User_mobile}) "
                    "CREATE (u)-[:PURCHASED {item: $item, details: $details}]->(p:Purchase {id: randomUUID()})",
                    **purchase_data.dict()
                )
            return {"statuscode": 200, "status": "success", "message": "Purchase recorded"}
        finally:
            driver.close()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000, reload=True)
